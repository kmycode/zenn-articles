---
title: "第1章　4　1つの型の責務を明確にし、複数の責務を含めない"
emoji: "🤮"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['csharp', 'asukacs']
published: false
---

# 目次

これは連載「あすかの怪文書」の記事です。[目次はこちらからご覧になれます](https://zenn.dev/kmy/articles/asuka-cs-0-index)

# 言い訳

型は責務を持つと、[初心者による虚構と誤解にまみれたDDDの説明](https://zenn.dev/kmy/articles/asuka-cs-1-1-ddd)で述べました。ここでは、１つの型に複数の責務を持たせてはいけないという考え方を詳しく掘り下げます。
これは、SOLID原則の単一責任の原則（SRP）に深く関係します。

# 下書き（出版社に提出したサンプル原稿）

例えば、３秒後に画面に文字を表示するプログラムを考えます。この「３秒待つ」という処理を書く時に２０行以上の記述が必要だとします。（実際は１行で済みますがあくまで例えです）

```cs
class TreeShaker
{
  public Fruit Shake(Tree tree)
  {
    // 3秒待つために20行くらいの処理

    // 処理
  }
}
```

しかし、この「3秒待つ」という処理は汎用的かつ冗長です。汎用的とはつまり、他のクラスからも同じ処理をおこないたくなることがあるはずです。その時にいちいちこの２０行の処理をコピペしなければいけません。それでは３秒待つアルゴリズムを変更する時に、コピペした部分をいちいち修正しなければならず、苦労するでしょう。そこで、この処理を別のメソッドに切り出します。どのクラスからも容易にアクセスできるよう、staticメソッドにします。

```cs
class TreeShaker
{
  public Fruit Shake(Tree tree)
  {
    Wait(3);

    // 処理
  }

  public static void Wait(int seconds)
  {
    // 20行くらいの処理
  }
}
```

そして、あなたは別のクラスで同様の処理を実行したいと考えます。その時に、Waitメソッドを以前作っていたことを思い出し、それを探します。しかし、まさか「TreeShakerクラスに待機処理が入っているだろうな」と考えることはないでしょう。これは、TreeShakerクラスは木を揺らす処理を行うものだと期待しているからです。期待されていない動きは大抵の場合、見過ごされます。期待以上の成果を出した人は会社では表彰されますが、クラス設計においては、散々探しつくした後で出てくるものですから、「何でここにいるの？」という小言ばかり言われることになります。この問題の解決法は簡単で、TreeShakerクラスに期待されていないメソッドは別のクラスに切り出すべきです。

```cs
class Sleeper
{
  public static void Wait(int seconds)
  {
    // 20行くらいの処理
  }
}
```

たったこれだけで、このWaitメソッドを探し出しやすくなります。（この一連の考え方は、驚き最小の原則ともいいます）
これには複数のメリットがあります。まず、Waitメソッドの呼び出しを自然言語的に記述できるということです。以下の２つの呼び出しは、どちらがよりWaitメソッドの性質を表現したものだと思いますか？

```cs
TreeShaker.Wait(3);
Sleeper.Wait(3);
```

上のコードでは、「木を揺らして３秒待つ処理である」と誤解されることもありますし、Waitメソッドの役割を正しく理解していたとしても、「なぜこのクラスに入れたっけ？」と疑問に思うことになります。対して下のコードは、Waitがただ待機処理のみを行うことがひと目で分かります。
次のメリットは、Waitメソッドそのものをコピペする必要がなくなることです。TreeShakerクラスにWaitメソッドが入っていれば、別のクラス、例えばFishingクラスやBaseballクラスなどにも同様にWaitメソッドをコピペしたいと考える人は必ずいます。なぜなら「このWaitメソッドはTreeShakerクラスのために特別にカスタマイズされたものであり、他のクラスでも同様にカスタマイズされたWaitメソッドが必要だ」という誤解が発生するからです。そして必然的に他のクラスにWaitメソッドがコピペされ、コードは不要な重複を引き起こし、保守性を低下させます。待機処理専用、または汎用処理専用のクラスを作れば、これは汎用化された処理でありどこでも使えるものであることがひと目でわかり、コピペすることはなくなります。
そして次のメリットは、最も重要なもので、クラスに責務と異なる変数や処理を混入しづらくなることです。例えばWaitメソッドの実行に、threadWatcherという名前の変数が必要になったことを考えます。

```cs
class TreeShaker
{
  // Waitメソッドで使う
  // ThreadWatcherは架空のクラス
  private static ThreadWatcher threadWatcher;

  public Fruit Shake(Tree tree)
  {
    Wait(3);

    // 処理
  }

  public static void Wait(int seconds)
  {
    // 20行くらいの処理
  }
}
```

今回はシンプルなコードなのでまだいいですが、実はこれはクラスの保守性を著しく低下させます。１つのクラスに複数の責務があるということは、それぞれの責務のためのメソッドや変数を混在させるということです。どの変数がどのメソッドのためにあるのか、どのメソッドがどの責務のためにあるのか、呼び出し側だけでなくクラス内部でも非常に分かりづらくなります。ときには、別の責務を持ったメソッドの専用変数なのに間違って再使用してしまったためにバグが起きた、ということも頻発します。これを避けるために、異なる責務は異なるクラスに分割すべきなのです。
