---
title: "第1章　5　アクセス修飾子はprivateを優先的に検討する"
emoji: "🤮"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['csharp', 'asukacs']
published: false
---

# 目次

これは連載「あすかの怪文書」の記事です。[目次はこちらからご覧になれます](https://zenn.dev/kmy/articles/asuka-cs-0-index)

# 言い訳

[初心者が背伸びして書いた間違いだらけの痛い記事](https://zenn.dev/kmy/articles/asuka-cs-1-0-summary)で述べたとおり、オブジェクト指向の本質はカプセル化であるというのが私の持論（笑）です。カプセル化とは、クラスの内部仕様を隠し、外部に対して責務に見合った必要なインターフェースのみを公開することです。カプセル化のメリットは数多くあり、中には保守性や拡張性の向上につながるものも含まれます。
今回の話は、SOLID原則のOCP（オープンクローズド原則）の話と半分重なります。OCPは「修正に閉じ、拡張に開く」という原則ですが、本記事では前者のみを紹介します。ですが、前者を守ることで自然と後者のメリットの享受に繋がりますので、それはそれでかなり重要な内容でもあります。
本連載よりも明らかに有益で的確な記事がインターネットには大量にありますのでそちらをお読みくださり、この連載には近寄らないでください。

# 問題

あるデータフォーマットを読み込むためのクラスを作成しました。

```cs
class CsvStringReader
{
  public string[] data;

  public CsvStringReader(string raw)
  {
    this.data = raw.Split(",");
  }

  public int GetAsInt(int index)
  {
    return int.Parse(this.data[index]);
  }
}
```

このクラスは、文字列データを以下のように読み込むことを想定しています。

```cs
var reader = new CsvStringReader("32,41");
var val = reader.GetAsInt(1);
```

しかし、このクラスにはある重大な問題点があります。この問題のために、このクラスはバグを起こす可能性をはらんでいます。一体何がいけないのでしょうか？

## どこが問題？

### 問題１

ただ一点、`data`が`public`になっています。つまりこのクラスの呼び出し側で、以下のようなプログラムが書けてしまいます。

```cs
var reader = new CsvStringReader("32,41");
reader.data = new string[] { "66", "37", };

// 37 is returned
var val = reader.GetAsInt(1);
```

以上のコードのように、外側からデータを書き換えることが出来ます。クラスの呼び出し側が、自由に内部データへアクセスできる状態です。
ただ、本連載ではこれまでにも、プロパティの`set`アクセサを公開することで外部から自由に状態を書き換え可能なクラスを作ってきました。これだけのコードでは何が問題なのか分かりづらいかもしれません。そこで、もうひとつ処理を付け足してみます。

```cs
class CsvStringReader
{
  public string[] data;

  public CsvStringReader(string raw)
  {
     // 空っぽのデータは0に変換される
     this.data = raw.Split(",")
      .Select((d) =>
      {
        if (!int.TryParse(d, out int _))
        {
          return "0";
        }
        return d;
      })
      .ToArray();
  }

  public int GetAsInt(int index)
  {
    return int.Parse(this.data[index]);
  }
}
```

:::message
本来なら`TryParse`した時点で`int`の配列を作るのがパフォーマンス面において最適ですが、説明の都合上このようにしています
:::

データのバリデート処理、正しい形式に変形する処理がここに入っていた場合を考えます。上記の例では、空っぽの文字列を`0`に変換します。ここで以下のコードを実行すると、条件にマッチしたデータは自動的に変換されます。

```cs
var reader = new CsvStringReader("17,,8");
// reader.data = { "17", "0", "8", }
```

このように、`CsvStringReader`クラスは自分のメソッドの中でデータが適切に扱われるように変換します。なぜこの変換をするかというと、`GetAsInt`メソッドの存在にあります。

```cs
  public  int GetAsInt(int index)
  {
    // 数値に変換できない文字列を渡すと例外が投げられる
    return int.Parse(this.data[index]);
  }
```

このメソッド内で使用している`int.Parse`メソッドは`23`や`55`など文字列で表現された数値を、`int`型の数値に変換します。この`int.Parse`メソッドに空文字列`""`を渡すと、例外が投げられます。ここで例外が起きないように、コンストラクタの時点でデータを加工するよう修正しました。
では、ここでもう一度、呼び出し部分のプログラムを書いてみましょう。

```cs
var reader = new CsvStringReader("45,,83");
// reader.data = { "45", "0", "83", }

reader.data = new string[] { "45", "", "83", };
// reader.data = { "45", "", "83", }

var val = reader.GetAsInt(1);    // エラー発生
```

上のコードの１行目と３行目は一見同じことをやっているように見えます。しかし、３行目にはコンストラクタ内でのデータ加工処理が一切介入していません。そのために、`int.Parse`メソッドへ渡す引数への適切な加工処理がなされず、エラーが発生します。これは、既存のコードからバグを取り除く作業、時には既存のコードに機能追加する作業をまったくの無意味にし、保守性を損ないます。

### 問題２

呼び出し側は、`GetAsInt`メソッドを呼び出すことにより、このデータを数値として取得することが出来ます。しかしここで問題なのは、所定のデータへアクセスできる手段が２つあるということです。
例えば、このクラスに`GetAsString`メソッドを追加したときのことを考えましょう。

```cs
class CsvStringReader
{
  public string[] data;

  public CsvStringReader(string raw)
  {
    // ...
  }

  public int GetAsInt(int index)
  {
    // ...
  }

  public string GetAsString(int index)
  {
    return this.data[index];
  }
}
```

これは指定した位置にある配列の要素をそのまま返却します。ここで問題なのは、**所定の状態へアクセスする手段が２つ提供されている**ということです。
呼び出し側は、以下のうちいずれでも、目的のデータへアクセスできます。

```cs
var reader = new CsvStringReader("17,55");

// 想定する呼び出し方
var val1 = reader.GetAsString(1);

// 他の呼び出し方
var val2 = reader.data[1];
```

もし、`reader.GetAsString`と`reader.data`２種類のアクセス方法がプログラム内に混在していたら、何が起こるでしょうか？
例えば、あなたが`GetAsString`メソッドにおいて以下の修正を加えるとします。

```cs
  public string GetAsString(int index)
  {
    if (index >= this.data.Length)
    {
      return string.Empty;
    }
    return this.data[index];
  }
```

今更ではありますが、インデックス番号が配列の大きさを超えていた時は空の文字列を返すよう修正しました。これによって`IndexOutOfRangeException`が発生するリスクは取り除かれました。ただしそれは、`GetAsString`メソッドを呼び出した場合に限ります。`reader.data`へ直接アクセスした場合、このリスクは依然として残りますし、またフィールド配列のインデクサの挙動へ任意の処理をインジェクションすることはできません（自分で`IList<string>`を実装して作ったクラスなら話は別ですが、そのようなことができる人はまずこの記事を読みません）。プログラムのあちこちに点在する`reader.data`を片っ端から修正する作業に追われることになります。

:::message
C#とJavaで中身は同じなのに名前の違う例外クラスがあるの何とかしてください。私はJavaを使わなくなって久しいですが、いまだ配列といえば`IndexOutOfBoundsException`が最初に思い浮かびます
:::

同じ操作へのアクセス手段が複数あることは、上記のようにプログラムの保守性を損ないます。

## アプローチ

この問題の解決は、極めてシンプルです。たった１箇所の`public`を`private`にするだけです。

```cs
class CsvStringReader
{
  private string[] data;

  // ...
}
```

[にわかによるにわかのための誤謬の塊の作成を推奨する記事](https://zenn.dev/kmy/articles/asuka-cs-1-3-customclass)において、データをルールよりも型で表現すべきであると述べました。しかしあの記事で取り上げたケースはリファクタリング可能なルールであり、リファクタリングによって自然消滅し得るものであったために問題になりました。
今回、`data`はクラスの責務を果たすために定めるべき必要最低限のルールであり、リファクタリングによって消滅することはありません。問題はこのルールを、外部へ公開してしまったことにあります。

`data`は、このクラスへの入力ではありません。入力を、このクラスの処理で扱いやすいように内部で変換したデータです。そこを履き違えてはいけません。
`CsvStringReader`クラスの責務は、以下のようになっているはずです。

* コンマで区切られた文字列の特定の位置にあるデータを取得する
  * 入力: コンマで区切られた文字列
  * 出力: 特定の位置にあるデータ

`data`は、このクラスの入力と出力のどちらにも該当しません。入力から出力へ変換する過程で生み出されたデータであり、このクラスの内部処理に該当します。これを公開すると、カプセル化が困難になり、上記のようにクラスを修正する時に問題を起こします。

上記の修正によって、呼び出し側がデータにアクセスする手段は、以下が唯一になります。

```cs
var reader = new CsvStringReader("45,,83");

var val1 = reader.GetAsInt(1);
var val2 = reader.GetAsString(1);
```

特定の情報へアクセスする手段が唯一であるということは、保守性の観点できわめて重要です。そのアクセス手段に問題があれば、そこだけを修正すればいいのです。

また、呼び出し側がクラスの内部仕様にアクセスできないようにすることは、その内部仕様への信頼性を向上させ、クラスの修正または拡張を容易にします。なぜなら、`private`な変数にアクセスできるのはそのクラスの中からのみであり、その変数の仕様変更が必要になった時の**メンテナンス範囲が非常に絞られる**からです。これはクラスの保守をスピーディーにします。コード修正における影響範囲は、`private`を設定することによって可能な限り最小限にすべきです。

クラスは無駄なメンバーを公開すべきではありません。SRPより規模こそ小さいですが、下手すると現金換算できるレベルの損失が必ず発生します。呼び出し側はこのクラスに何を期待しているか（責務）、その期待を滿足するにはどのメソッドやプロパティを公開すべきか、クラス設計者は吟味すべきです。

:::message
慣れないうちは、とにかく全部`private`にして後から必要なものだけを`public`にするトレーニングもありです
:::

# 目次

これは連載「あすかの怪文書」の記事です。[目次はこちらからご覧になれます](https://zenn.dev/kmy/articles/asuka-cs-0-index)
